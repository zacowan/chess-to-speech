"""This module contains all of the routes accessible to the client.

Attributes:
    bp: The blueprint that the __init__.py will use to handle routing.

"""
from threading import Thread
from flask import (
    Blueprint, request, jsonify
)

from . import speech_text_processing, dialogflow_andy
from .intent_processing import intent_processing
from .logging import (
    create_intent_log,
    update_intent_log_with_audio_response,
    create_error_log,
    ERROR_TYPES
)
from .api_route_helpers import get_response_error_return, get_static_error_audio

bp = Blueprint('api', __name__, url_prefix='/api')


@bp.route("/get-audio-response", methods=["POST"])
def get_audio_response():
    """Route for getting audio data from text.

    Query Params:
        session_id: the unique session ID to use with Andy.

    Body:
        Text that should be converted into audio.

    Returns:
        An HTTP response, with the data field containing the raw bytes of the
        audio file. The data field will only be present if the status code of
        the response is 200.

    """
    # pylint: disable=broad-except
    if request.method == "POST":
        session_id = request.args.get('session_id')

        # Make sure query params are present
        if not session_id:
            raise Exception("get-audio-response: missing session_id")

        # Convert response to audio
        try:
            response_audio = speech_text_processing.generate_audio_response(
                request.data)
        except Exception as e:
            err_msg = f"Error with text-to-speech: {e}"
            create_error_log(session_id, ERROR_TYPES.TTS, err_msg)
            # Return a static audio response
            return get_static_error_audio()

        # Log the audio response on a separate thread
        Thread(target=update_intent_log_with_audio_response(
            session_id, audio_data=response_audio)).start()

        return response_audio


@bp.route("/get-response", methods=["POST"])
def get_response():
    """Route for getting a response from Andy and any actions to take.

    Query Params:
        session_id: the unique session ID to use with Andy.
        board_str: FEN representation of board from client.
        detected_text: the text detected from the user.

    Body:
        A Blob that contains the audio to interpret.

    Returns:
        An HTTP response, with the data field containing a JSON object. The data
        field will only be present if the status code of the response is 200.

        {
            'response_text': str,
            'board_str': str
            'fulfillment_info': dict
        }

        response_text (str): the response generated by Andy, as text.
        fulfillment_info (dict): the intent information detected from the user
            and the game state.

            {
                'intent_name': str,
                'success': boolean
            }

            intent_name (str): the name of the detected intent.
            success (boolean): whether or not the fulfillment for the intent was
                performed successfully.
        board_str (str): the state of the board, as a FEN string.

    """
    # pylint: disable=broad-except
    if request.method == "POST":
        session_id = request.args.get('session_id')
        detected_text = request.args.get('detected_text')
        # grab board string from HTTP arguments
        board_str = request.args.get('board_str')

        # Make sure query params are present
        if not session_id or not board_str or not detected_text:
            raise Exception(
                "get-response: missing session_id or board_str or detected_text")

        # Detect intent from text
        intent_query_response = None
        try:
            intent_query_response = dialogflow_andy.perform_intent_query(
                session_id, detected_text)
        except Exception as e:
            # Log the error
            err_msg = f"Error with intent detection: {e}"
            create_error_log(session_id, ERROR_TYPES.INTENT, err_msg)
            # Return an error response
            return get_response_error_return(board_str)

        # Determine Andy's response
        try:
            response_text, fulfillment_info, updated_board_str = intent_processing.fulfill_intent(
                intent_query_response, board_str)
        except Exception as e:
            # Log the error
            err_msg = f"Error performing fulfillment: {e}"
            create_error_log(session_id, ERROR_TYPES.FULFILLMENT, err_msg)
            # Return an error response
            return get_response_error_return(board_str)

        # Log the intent request on a separate thread
        Thread(target=create_intent_log(
            session_id,
            audio_data=request.data,
            data={
                "board_str_before": board_str,
                "board_str_after": updated_board_str,
                "detected_intent": fulfillment_info["intent_name"],
                "intent_success": fulfillment_info["success"],
                "andy_response_text": response_text,
                "user_input_text": detected_text,
            })).start()

        return jsonify({
            'response_text': response_text,
            'fulfillment_info': fulfillment_info,
            'board_str': updated_board_str,
        })
